
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>VMware Tanzu Application Service (Cloud Foundry) for Kubernetes Hands-on Lab</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-77753174-1"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="tas-for-k8s-hol"
                  title="VMware Tanzu Application Service (Cloud Foundry) for Kubernetes Hands-on Lab"
                  environment="web"
                  feedback-link="https://docs.google.com/document/d/1bgn4fFkVU7AqrbFPZkDY9Sr5rjKmMal74-Aq30qsPPk/edit">
    
      <google-codelab-step label="Hands-on Labに必要なもの" duration="10">
        <p>このHands-on Lab資料は、準備済みの<a href="https://network.pivotal.io/products/tas-for-kubernetes" target="_blank">Tanzu Application Service for Kubernetes</a>を使用して行うことを前提としていますが、オープンソースのの<a href="https://cf-for-k8s.io" target="_blank">Cloud Foundry for Kubernetes</a>環境でも多くのコンテンツは利用可能です。</p>
<p>以下のソフトウェアをインストールしてください。</p>
<ul>
<li><a href="https://bell-sw.com/pages/downloads/#/java-11-lts" target="_blank">Java 11</a></li>
<li>CF CLI (v7)</li>
<li><a href="https://curl.haxx.se/" target="_blank"><code>curl</code></a></li>
<li><a href="https://stedolan.github.io/jq/" target="_blank"><code>jq</code></a></li>
<li><code>tar</code></li>
</ul>
<p>CF CLI (v7)は<a href="https://github.com/cloudfoundry/cli/releases/tag/v7.1.0" target="_blank">こちら</a>からダウンロードしてください。<code>cf</code>という名前で使用します。</p>
<pre><code>$ cf -v
cf version 7.1.0+4c3168f9a.2020-09-09</code></pre>
<aside class="special"><p>Note: 執筆時に動作確認した環境には次のプロダクトがインストールされています。</p>
<ul>
<li><a href="https://network.pivotal.io/products/tas-for-kubernetes" target="_blank">Tanzu Application Service for VMs</a> 3.0.0</li>
<li><a href="https://github.com/making/elephantsql-service-broker" target="_blank">ElephantSQL Service Broker</a></li>
</ul>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Tanzu Application Serviceにログイン" duration="15">
        <p><br>次のコマンドでHands-on Lab用の環境にログインします。</p>
<pre><code>cf login -a api.cf.maki.lol -o hol --sso</code></pre>
<aside class="warning"><p>Note: 用意されたHands-on Lab用の環境以外の環境で実施する場合は、その環境に合わせてログインしてください。</p>
</aside>
<p>次のように認証コードの入力が求められますので、<a href="https://login.cf.maki.lol/passcode" target="_blank">https://login.cf.maki.lol/passcode</a>にSSOでログインして認証コードを取得し、コンソールに入力してください。</p>
<pre><code>cf login -a api.cf.maki.lol -o hol --sso

API endpoint: api.cf.maki.lol

Temporary Authentication Code ( Get one at https://uaa.cf.maki.lol/passcode ): </code></pre>
<p>認証コードを入力すると、ログインが成功し、次のように自動でSpaceが設定されていることを確認してください。</p>
<pre><code>Authenticating...
OK


Targeted org hol.

Targeted space tmaki.

API endpoint:   https://api.cf.maki.lol
API version:    3.90.0
user:           makingx@gmail.com
org:            hol
space:          tmaki</code></pre>
<p>次のコマンドでアクセスしている環境の情報を確認してください。</p>
<pre><code>$ cf curl /info
{
   &#34;name&#34;: &#34;&#34;,
   &#34;build&#34;: &#34;&#34;,
   &#34;support&#34;: &#34;&#34;,
   &#34;version&#34;: 0,
   &#34;description&#34;: &#34;&#34;,
   &#34;authorization_endpoint&#34;: &#34;https://login.cf.maki.lol&#34;,
   &#34;token_endpoint&#34;: &#34;https://uaa.cf.maki.lol&#34;,
   &#34;allow_debug&#34;: true,
   &#34;user&#34;: &#34;5548c6ab-3935-4266-8f61-5a49dd2cb3a5&#34;,
   &#34;limits&#34;: {
      &#34;memory&#34;: 2048,
      &#34;app_uris&#34;: 4,
      &#34;services&#34;: 16,
      &#34;apps&#34;: 20
   },
   &#34;usage&#34;: {
      &#34;memory&#34;: 32,
      &#34;apps&#34;: 1,
      &#34;services&#34;: 0
   }
}</code></pre>
<aside class="warning"><p>Note: WindowsでGit Bashを使う場合は<br><code>export MSYS_NO_PATHCONV=1</code></p>
<p>を設定してください。</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="雛形アプリケーションのデプロイ" duration="30">
        <h2 is-upgraded>Spring Initialzrで雛形アプリケーションの作成</h2>
<p><a href="https://start.spring.io" target="_blank">Spring Initializr</a>でSpring Bootの雛形アプリケーションを作成し、cf pushで早速デプロイします。</p>
<p>作業場所として<code>hol</code>ディレクトリを作成してください。</p>
<pre><code>mkdir hol
cd hol</code></pre>
<p><br>次のコマンドで雛形アプリケーションを作成します。</p>
<pre><code>curl https://start.spring.io/starter.tgz \
       -d artifactId=hello-cf \
       -d baseDir=hello-cf \
       -d dependencies=web,actuator,configuration-processor,prometheus \
       -d packageName=com.example \
       -d applicationName=HelloCfApplication | tar -xzvf -</code></pre>
<p><br>次のコマンドでアプリケーションをビルドします。</p>
<pre><code>cd hello-cf
./mvnw clean package -Dmaven.test.skip=true</code></pre>
<aside class="warning"><p>Note: WindowsでGit Bashを使う場合は<code>./mvnw</code>の代わりに<code>./mvnw.cmd</code>を使ってください。</p>
</aside>
<h2 is-upgraded><br>cf pushでデプロイ</h2>
<p><code>hello-cf</code>ディレクトリの下に<code>manifest.yml</code>を作成し、次の内容を記述してください。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar</code></pre>
<aside class="warning"><p>Note: Hands-on Labでは複数の人が同じnameでアプリケーションをデプロイします。デフォルトではアプリケーションのURLのHost部分がnameと同じになるため、URLの衝突が発生します。これを回避するために<code>random-route: true</code>をつけて、Host部分にランダムな文字列を追記するようにします。</p>
</aside>
<p><code>cf push</code>でアプリケーションをデプロイします。</p>
<pre><code>cf push</code></pre>
<p><br>次のコマンドで</p>
<pre><code># ランダムな文字列を含むHost部分を取得し、変数に設定する
HOST=$(cf curl /v3/apps/$(cf app hello-cf --guid)/routes | jq -r &#34;.resources[0].host&#34; )

# Spring Boot AcutatorのHealthエンドポイントにアクセス
curl -s https://${HOST}.apps.cf.maki.lol/actuator/health -w &#39;\n&#39;</code></pre>
<p><br>次のように出力されればOKです。</p>
<pre><code>{&#34;status&#34;:&#34;UP&#34;}</code></pre>
<h2 is-upgraded>Spring Boot Actuatorのエンドポイント公開</h2>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html" target="_blank">Spring Boot Actuator</a>には運用に役立つ便利なエンドポイントが多数用意されています。デフォルトでは<code>/actuator/info</code>と<code>/actuator/health</code>のみ公開されています。<code>manifest.yml</code>に次の環境変数を設定して、<code>/actuator/env</code>と<code>/actuator/prometheus</code>も公開しましょう。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  # ⭐️⭐️⭐️
  env:
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus</code></pre>
<p><code>cf push</code>でアプリケーションをデプロイします。</p>
<pre><code>cf push</code></pre>
<p>次のコマンドで各エンドポイントにアクセスしてください。</p>
<pre><code># 公開中のActuatorエンドポイントの列挙
curl -s https://${HOST}.apps.cf.maki.lol/actuator | jq .

# Envエンドポイントにアクセス
curl -s https://${HOST}.apps.cf.maki.lol/actuator/env | jq .

# Prometheusエンドポイントにアクセス
curl -s https://${HOST}.apps.cf.maki.lol/actuator/prometheus</code></pre>
<aside class="special"><p>Note: Envエンドポイントはアプリケーションの内部情報を含むため、publicに公開しないのが一般的です。</p>
</aside>
<h2 is-upgraded>Infoエンドポイントの活用</h2>
<p>Infoエンドポイントは<code>info.</code>から始まるプロパティまたは、<code>INFO_</code>から始まる環境変数をJSON形式で出力します。動作アプリのバージョンなど含めておくと便利です。</p>
<p><code>manifest.yml</code>に次の環境変数を設定してください。<br></p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  env:
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    # ⭐️⭐️⭐️
    INFO_VERSION: 0.0.1
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}</code></pre>
<p><code>cf push</code>でアプリケーションを再度デプロイします。</p>
<pre><code>cf push</code></pre>
<p><br>次のコマンドでInfoエンドポイントにアクセスしてください。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq .
{
  &#34;java&#34;: {
    &#34;vendor&#34;: &#34;BellSoft&#34;,
    &#34;version&#34;: &#34;11.0.8+10-LTS&#34;
  },
  &#34;version&#34;: &#34;0.0.1&#34;
}</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="ログの確認" duration="5">
        <p>アプリケーションのログは<code>cf logs</code>コマンドで確認できます。<code>--recent</code>オプションをつけることで、直近のログを確認できます。</p>
<pre><code>cf logs hello-cf --recent</code></pre>
<p><br>オプションをつけない場合は、ログを追跡します。</p>
<pre><code>cf logs hello-cf</code></pre>
<p>後ほどApps Managerでもログを確認します。<br></p>
<aside class="special"><p>Note: <strong>TODO</strong> update<br>アプリケーションエンジニアの責任範囲内で、アプリ単位でlogを外部のSyslog Serverに転送したい場合は、<a href="https://docs.cloudfoundry.org/devguide/services/log-management.html" target="_blank">Syslog Drain</a>という機能を利用できます。</p>
<p><a href="https://docs.pivotal.io/platform/application-service/2-8/loggregator/agent-architecture.html" target="_blank">Aggregate Syslog Drain</a>というPlatformの機能を使い、全てのアプリログをSyslog Serverに転送することもできます。</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Apps Managerの確認およびSpring Boot Actuator連携" duration="30">
        <p>Apps Manager(<a href="https://console.cf.maki.lol" target="_blank">https://console.cf.maki.lol</a>)にアクセスしてください。</p>
<p>hol Org &gt; ユーザー名 Space &gt; hello-cfと選択してください。</p>
<p class="image-container"><img style="width: 601.70px" src="img/e954e72be4f84568.png"></p>
<p>アプリケーションにSpring Boot Actuatorが含まれている場合は、Apps ManagerからSpring Boot Actuatorのエンドポイントにアクセスできます。<img style="width: 29.66px" src="img/c108897736d6085f.png">マークがついていれば連携できています。<br><a href="https://docs.pivotal.io/platform/application-service/2-10/console/using-actuators.html" target="_blank">https://docs.pivotal.io/platform/application-service/2-10/console/using-actuators.html</a></p>
<h2 is-upgraded>Healthエンドポイントの確認</h2>
<p>インスタンス情報の左の&#34; &gt; &#34;をクリックしてください。Healthエンドポイントの情報が詳細付きで表示されます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/8211348a2d1074c9.png"></p>
<aside class="special"><p>Note: Healthエンドポイントの詳細の見せ方は<code>management.endpoint.health.show-details</code>プロパティで変更できますが、publicなエンドポイントには詳細を見せないのが一般的です。Apps Manager経由でアクセスした場合は詳細が表示されます。</p>
</aside>
<h2 is-upgraded>Infoエンドポイントの確認</h2>
<p>左のメニューの&#34;Settings&#34;をクリックし、&#34;Spring Boot Info&#34;の&#34;VIEW RAW JSON&#34;をクリックしてください。<code>curl</code>で確認した時と同じ情報を見ることができます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/17b56f9e117ede6.png"></p>
<aside class="special"><p>Note: <code>MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE</code>から<code>info</code>を除外しても、Apps ManagerからはInfoエンドポイントにアクセスできます。Infoエンドポイントの内容をpublicにしたくない場合<code>はMANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLU</code>DEに<code>info</code>を含めず、Apps Managerからのみ確認できるようにしておくと良いです。</p>
</aside>
<aside class="special"><p>Note: 次の設定を行い、ビルド時にgitの情報を埋め込むとApps Manager上にgitの情報も表示されるようになります。</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-application-info-git" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-application-info-git</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-git-info" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-git-info</a></li>
</ul>
<p class="image-container"><img style="width: 601.70px" src="img/ae86edcebf66b3ed.png"></p>
<p><a href="https://docs.pivotal.io/platform/application-service/2-8/console/using-actuators.html#view-build" target="_blank">https://docs.pivotal.io/platform/application-service/2-8/console/using-actuators.html#view-build</a></p>
</aside>
<h2 is-upgraded>ThreadDumpエンドポイントの確認</h2>
<p>左のメニューの&#34;Threads&#34;をクリックしてください。アプリケーションのスレッドダンプを取得できます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/4b1fc793c7a400.png"></p>
<h2 is-upgraded>Loggingエンドポイントの確認</h2>
<p>左のメニューの&#34;Logs&#34;をクリックしてください。<code>cf logs --recent</code>コマンドと同じく直近のログを確認できます。<img style="width: 25.96px" src="img/5f59a1de02197201.png">ボタンをクリックするとログをtailできます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/402cb1ac5055d46d.png"></p>
<p>&#34;CONFIGURE LOGGING LEVEL&#34;ボタンをクリックするとログレベルを動的に変更するためのダイアログが表示されます。検索フィールドに&#34;DispatcherServlet&#34;を入力し、レベルをDEBUGに変更してください。</p>
<p class="image-container"><img style="width: 601.70px" src="img/c6f373ec75cab0c4.png"></p>
<p><img style="width: 25.96px" src="img/5f59a1de02197201.png">ボタンをクリックして、ログをtailしている状態で、アプリケーションにアクセスするとDispatcherServletのDEBUGログが出力されることを確認できます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/2deef386203b838c.png"></p>
<p>この変更はアプリケーションが再起動されるまで反映されます。トラブルシュートのためにアプリケーションを再起動することなく一時的にDEBUGログを出力したい場合に有用です。</p>


      </google-codelab-step>
    
      <google-codelab-step label="環境変数の設定およびUser Provided Serviceの使い方" duration="60">
        <p>アプリにプロパティを設定する方法をいくつか見ていきます。</p>
<h2 is-upgraded>アプリケーションへ環境変数の埋め込み</h2>
<p>まずはアプリケーションに環境変数で変更可能なプロパティ(<code>api.key</code>)を作成し、アプリケーションがそのプロパティを使うようにします。</p>
<p>次のファイルを新規作成してください。<br></p>
<p><code>src/main/java/com/example/ApiProperties.java</code></p>
<pre><code>package com.example;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &#34;api&#34;)
public class ApiProperties {

    private String key = &#34;SECRET&#34;;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }
}</code></pre>
<p><code>src/main/java/com/example/HelloController.java</code></p>
<pre><code>package com.example;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    private final ApiProperties props;

    public HelloController(ApiProperties props) {
        this.props = props;
    }

    @GetMapping(path = &#34;/&#34;)
    public ResponseEntity&lt;?&gt; hello(@RequestHeader(name = &#34;X-Api-Key&#34;, required = false) String apiKey) {
        if (props.getKey().equals(apiKey)) {
            return ResponseEntity.ok(&#34;Hello&#34;);
        } else {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(&#34;Forbidden&#34;);
        }
    }
}</code></pre>
<p><br>まずは<code>manifest.yml</code>に次のように環境変数<code>API_KEY</code>をハードコードします。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  env:
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    INFO_VERSION: 0.0.2 # ⭐️
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    # ⭐️⭐️⭐️
    API_KEY: opensesami</code></pre>
<aside class="special"><p>Note: Spring Bootでは<code>foo.bar-baz</code>というプロパティを環境変数で設定する場合は、&#34;<code>.</code>&#34;や&#34;<code>-</code>&#34;が使えないので、代わりに<code>FOO_BARBAZ</code>という名前を使うことができます。</p>
</aside>
<p><br>アプリケーションをビルドして再度<code>cf push</code>します。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true
cf push</code></pre>
<p><br>HTTPリクエストヘッダー&#34;<code>X-Api-Key</code>&#34;が<code>opensesami</code>の場合のみ<code>Hello</code>が返り、それ以外の場合は<code>Forbidden</code>が返ります。</p>
<pre><code>$ curl -sv https://${HOST}.apps.cf.maki.lol
&gt; GET / HTTP/2
&gt; Host: hello-cf-rested-nyala-dn.apps.cf.maki.lol
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; 
&lt; HTTP/2 403 
&lt; content-type: text/plain;charset=UTF-8
&lt; date: Mon, 02 Nov 2020 16:10:26 GMT
&lt; server: istio-envoy
&lt; x-envoy-upstream-service-time: 261
&lt; content-length: 9
&lt; 
Forbidden

$ curl -sv -H &#34;X-Api-Key: opensesami&#34; https://${HOST}.apps.cf.maki.lol
&gt; GET / HTTP/2
&gt; Host: hello-cf-rested-nyala-dn.apps.cf.maki.lol
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; X-Api-Key: opensesami
&gt; 
&lt; HTTP/2 200 
&lt; content-type: text/plain;charset=UTF-8
&lt; date: Mon, 02 Nov 2020 16:11:25 GMT
&lt; server: istio-envoy
&lt; x-envoy-upstream-service-time: 33
&lt; content-length: 5
&lt; 
Hello</code></pre>
<h2 is-upgraded>User Provided Serviceを経由して環境変数の設定</h2>
<p><code>manifest.yml</code>は通常gitで管理します。gitで管理されるファイルに直接API Keyをハードコードするのはセキュアではありません。手元のファイルに記述する代わりにPlatform側に保存しましょう。まずは<a href="https://docs.cloudfoundry.org/devguide/services/user-provided.html" target="_blank">User Provided Service</a>を使用します。次のコマンドで<code>hello</code>サービスインスタンスを作成します。<br></p>
<pre><code>cf create-user-provided-service hello -p &#39;{&#34;api-key&#34;:&#34;OPENSESAMI&#34;}&#39;</code></pre>
<p><code>hello</code>サービスインスタンスを<code>hello-cf</code>アプリにバインドするように<code>manifest.yml</code>を編集します。また、環境変数<code>API_KEY</code>の値を<code>hello</code>サービスインスタンスから<code>api-key</code>を取得するようにします。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  # ⭐️⭐️⭐️
  services:
  - hello
  env:
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    INFO_VERSION: 0.0.2
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    # ⭐️⭐️⭐️
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<aside class="special"><p>Note: <code>${vcap.services.&lt;service instance name&gt;.credentials.&lt;key name&gt;}</code>形式でサービスインスタンスから値を取得できるのはSpring Bootの機能です。その他の言語、フレームワークを使用する場合は環境変数<code>VCAP_SERVICES</code>からJSON文字列を取得し、これをパースして値を取得する必要があります。使用例は<a href="https://blog.ik.am/entries/529" target="_blank">こちら</a>。</p>
</aside>
<p><code>cf push</code>で再度デプロイします。</p>
<pre><code>cf push</code></pre>
<p>今度はHTTPリクエストヘッダー&#34;<code>X-Api-Key</code>&#34;が<code>OPENSESAMI</code>の場合のみ<code>Hello</code>が返り、それ以外の場合は<code>Forbidden</code>が返ります。</p>
<pre><code>$ curl -sv -H &#34;X-Api-Key: opensesami&#34; https://${HOST}.apps.cf.maki.lol
&gt; GET / HTTP/2
&gt; Host: hello-cf-rested-nyala-dn.apps.cf.maki.lol
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; X-Api-Key: opensesami
&gt; 
&lt; HTTP/2 403 
&lt; content-type: text/plain;charset=UTF-8
&lt; date: Mon, 02 Nov 2020 16:14:22 GMT
&lt; server: istio-envoy
&lt; x-envoy-upstream-service-time: 247
&lt; content-length: 9
&lt; 
Forbidden

$ curl -sv -H &#34;X-Api-Key: OPENSESAMI&#34; https://${HOST}.apps.cf.maki.lol
&gt; GET / HTTP/2
&gt; Host: hello-cf-rested-nyala-dn.apps.cf.maki.lol
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; X-Api-Key: OPENSESAMI
&gt; 
&lt; HTTP/2 200 
&lt; content-type: text/plain;charset=UTF-8
&lt; date: Mon, 02 Nov 2020 16:15:00 GMT
&lt; server: istio-envoy
&lt; x-envoy-upstream-service-time: 36
&lt; content-length: 5
&lt;  
Hello</code></pre>
<p><br>User Provided Serviceを使うことで<code>manifest.yml</code>にAPI Keyをハードコードしなくても済むようになりましたが、User Provided Serviceに格納した情報は暗号化されるわけではないことに注意してください。</p>
<pre><code>$ cf env hello-cf
Getting env variables for app hello-cf in org hol / space tmaki as tmaki@pivotal.io...
OK

System-Provided:
{
 &#34;VCAP_SERVICES&#34;: {
  &#34;user-provided&#34;: [
   {
    &#34;binding_name&#34;: null,
    &#34;credentials&#34;: {
     ⭐️⭐️⭐️&#34;api-key&#34;: &#34;OPENSESAMI&#34;
    },
    &#34;instance_name&#34;: &#34;hello&#34;,
    &#34;label&#34;: &#34;user-provided&#34;,
    &#34;name&#34;: &#34;hello&#34;,
    &#34;syslog_drain_url&#34;: &#34;&#34;,
    &#34;tags&#34;: [],
    &#34;volume_mounts&#34;: []
   }
  ]
 }
}
... (略) ...</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="アプリケーションのアップデート" duration="75">
        <p>アプリケーションのアップデートの方法を学びます。<code>cf push</code>コマンドでアプリケーションを再デプロイした場合は旧版のStop -&gt; 新版のStartというStepになります。この間はアプリケーションにアクセスできません(404エラー)。Tanzu Application Serviceではダウンタイムを起こさずにアプリケーションを更新する方法として、</p>
<ul>
<li>Blue-Green Update</li>
<li>Rolling Update</li>
</ul>
<p>が利用できます。</p>
<h2 is-upgraded>Blue-Green Update</h2>
<p>Blue-Green Updateは旧版と新版を同居した状態で両方のアプリにリクエストがルーティングされるようにし、新版でも問題なく動作することを確認したのちに、旧版へのルーティングを削除する手法です。フィードバックを受けながら徐々に新版に移行できる点と、新版に問題がある場合は旧版に切り戻しやすい点が特徴です。Blue-Green Updateでは旧版と新版は別の独立したアプリケーションとして扱われます。Tanzu Application Serviceでは旧版と新版へのリクエスト比率はそれぞれのインスタンス数に比例します。旧版と新版を同居させる場合、通常は余剰なリソースが必要になります。</p>
<p><a href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html" target="_blank">https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html</a></p>
<p>現在稼働中の<code>hello-cf</code>アプリをBlueとします。</p>
<p class="image-container"><img style="width: 600.00px" src="img/e7495e8cffd6e8ad.png"></p>
<p>BlueのバージョンをSpring Boot ActuatorのInfoエンドポイントで確認します。<br></p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.2</code></pre>
<p>次に新版(Green)をデプロイします。ここではアプリケーションのソースコードは変更せず、環境変数<code>INFO_VERSION</code>のみ変更します。<br><code>manifest.yml</code>を次のように変更してください。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  services:
  - hello
  env:
    INFO_VERSION: 0.0.3 # ⭐️
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<p><br>この<code>manifest.yml</code>を使い、アプリケーションを別名でpushします。</p>
<pre><code>cf push hello-cf-green</code></pre>
<p><code>cf apps</code>コマンドでアプリケーション一覧を表示し、二つのアプリケーションが稼働していることを確認してください。</p>
<pre><code>$ cf apps
Getting apps in org hol / space tmaki as makingx@gmail.com...

name             requested state   processes                               routes
hello-cf         started           web:1/1, executable-jar:0/0, task:0/0   hello-cf-rested-nyala-dn.apps.cf.maki.lol
hello-cf-green   started           web:1/1, executable-jar:0/0, task:0/0   hello-cf-green-comedic-capybara-dc.apps.cf.maki.lol</code></pre>
<p><br>次の図のような状態になっています。</p>
<p class="image-container"><img style="width: 600.00px" src="img/81ca53f831b20a35.png"></p>
<p><code>hello-cf-green</code>アプリに割り当てられたランダムなHost部を次のコマンドで取得します。</p>
<pre><code>HOST_NEW=$(cf curl /v3/apps/$(cf app hello-cf-green --guid)/routes | jq -r &#34;.resources[0].host&#34;)</code></pre>
<p>GreenのバージョンをSpring Boot ActuatorのInfoエンドポイントで確認します。<br></p>
<pre><code>$ curl -s https://${HOST_NEW}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3</code></pre>
<p>この段階ではBlueのバージョンに変更がないことも確認してください。<br></p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.2</code></pre>
<p><br>現時点ではBlueとGreenは全く別のアプリケーションとしてそれぞれ存在しています。GreenのURLはエンドユーザーには知られていないため、安全にテスト可能です。</p>
<p>次に、次の図のようにBlueに対するルートつまり、エンドユーザーが利用するURLをGreenにもマッピングします。これでエンドユーザーはBlueかGreenどちらかのアプリケーションにルーティングされます。</p>
<p class="image-container"><img style="width: 600.00px" src="img/9823f83da602742b.png"></p>
<p>次の<code>cf map-route</code>コマンドで<code>hello-cf-green</code>アプリに対して<code>hello-cf</code>と同じルートをマッピングします。</p>
<pre><code>$ cf map-route hello-cf-green apps.cf.maki.lol -n ${HOST}
Mapping route hello-cf-rested-nyala-dn.apps.cf.maki.lol to app hello-cf-green in org hol / space tmaki as makingx@gmail.com...
OK</code></pre>
<p><code>cf apps</code>コマンドでアプリケーション一覧を表示し、<code>hello-cf-green</code>アプリには二つのルートがマッピングされていることを確認してください。</p>
<pre><code>$ cf apps
Getting apps in org hol / space tmaki as makingx@gmail.com...

name             requested state   processes                               routes
hello-cf         started           web:1/1, executable-jar:0/0, task:0/0   hello-cf-rested-nyala-dn.apps.cf.maki.lol
hello-cf-green   started           web:1/1, executable-jar:0/0, task:0/0   hello-cf-rested-nyala-dn.apps.cf.maki.lol, hello-cf-green-comedic-capybara-dc.apps.cf.maki.lol</code></pre>
<p><br>元々BlueにマッピングされていたURLに何度かアクセスしてください。新旧両方のバージョンが返ります。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.2
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.2
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3</code></pre>
<p>次に、次の図のようにBlueへのRouteを削除し、エンドユーザーがGreenにしかルーティングされないようにします。<br><img style="width: 600.00px" src="img/4cb52df0d97e79dd.png"></p>
<p>次の<code>cf unmap-route</code>コマンドを実行し、<code>hello-cf</code>アプリから元のルートをアンマップしてください。</p>
<pre><code>$ cf unmap-route hello-cf apps.cf.maki.lol -n ${HOST}
Removing route hello-cf-rested-nyala-dn.apps.cf.maki.lol from app hello-cf in org hol / space tmaki as makingx@gmail.com...
OK</code></pre>
<p><code>cf apps</code>コマンドでアプリケーション一覧を表示し、<code>hello-cf</code>アプリにはルートがマッピングされていないことを確認してください。</p>
<pre><code>$ cf apps
Getting apps in org hol / space tmaki as makingx@gmail.com...

name             requested state   processes                               routes
hello-cf         started           web:1/1, executable-jar:0/0, task:0/0   
hello-cf-green   started           web:1/1, executable-jar:0/0, task:0/0   hello-cf-rested-nyala-dn.apps.cf.maki.lol, hello-cf-green-comedic-capybara-dc.apps.cf.maki.lol</code></pre>
<p><br>元々BlueにマッピングされていたURLに何度かアクセスしてください。全て新バージョンが返ります。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3
$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3</code></pre>
<p><br>リクエストの100%がGreenにルーティングされても問題ないことを確認したら、Blueは停止または削除します。素早い切り戻し[1]をしたい場合は停止にしてください。またGreenにマップされている新しいルートは不要なので削除します。</p>
<p class="image-container"><img style="width: 600.00px" src="img/d394a3cf23860bb.png"></p>
<p>次のコマンドを実行してください。</p>
<pre><code># 過去のBlueがいたら削除
cf delete -f hello-cf-blue

# 切り戻しできるようにhello-cfをhello-cf-blueにリネーム
cf rename hello-cf hello-cf-blue 

# hello-cf-greenをhello-cfに昇格
cf rename hello-cf-green hello-cf

# hello-cf-blueをDelete(またはStop)
cf delete -f hello-cf-blue

# Greenにマップされている新しいルートはアンマップ
cf unmap-route hello-cf apps.cf.maki.lol -n ${HOST_NEW}

# アンマップされたルートを削除
cf delete-route apps.cf.maki.lol -n ${HOST_NEW} -f</code></pre>
<p><code>cf apps</code>コマンドでアプリケーション一覧を表示し、<code>hello-cf</code>アプリには元々のルートがマッピングされていることを確認してください。表示時上はGreenをデプロイする前と同じです。</p>
<pre><code>$ cf apps
Getting apps in org hol / space tmaki as tmaki@pivotal.io...
OK

name            requested state   instances   memory   disk   urls
hello-cf        started           1/1         768M     1G     hello-cf-bold-lion-rf.apps.cf.maki.lol</code></pre>
<aside class="special"><p>Note: 上記の手順は<a href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html" target="_blank">ドキュメント</a>に記載された通りのやり方ですが、次の手順でデプロイする方がStepが少なく済みます。</p>
<ol type="1" start="1">
<li>旧アプリの名前をrename。ここではsuffixに&#34;<code>-venerable</code>&#34;をつける。<br><code>cf rename hello-cf hello-cf-venerable</code></li>
<li>新アプリを旧アプリのの元の名前でデプロイ<br><code>cf push</code></li>
<li>新アプリに元のRouteをマッピング (<code>random-route: true</code>の場合のみ)<br><code>cf map-route hello-cf apps.cf.maki.lol -n ${HOST}</code> </li>
<li>旧アプリを削除または停止<br><code>cf delete -f hello-cf-venerable</code></li>
</ol>
</aside>
<h2 is-upgraded>Rolling Update</h2>
<p>CF CLI v7から、Rolling Updateがサポートされました。Blue-Green Updateとは異なり、旧版から新版へ一気にアップデートします。ただし複数インスタンスが存在する場合は、1インスタンスずつ順次アップデートされていくので、余剰なリソースは1インスタンスだけです。<br><br>まずは<code>cf scale</code>コマンドで<code>hello-cf</code>アプリを3インスタンスにスケールアウトします。</p>
<pre><code>cf scale hello-cf -i 3</code></pre>
<p><br>次に新版をデプロイします。ここでもアプリケーションのソースコードは変更せず、環境変数<code>INFO_VERSION</code>のみ変更します。<br><code>manifest.yml</code>を次のように変更してください。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 3 # ⭐️
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  services:
  - hello
  env:
    INFO_VERSION: 0.0.4 # ⭐️
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<p><code>cf push</code>コマンドでRolling Updateを行うために<code>--strategy rolling</code>オプションを加えてください。</p>
<pre><code>cf push --strategy rolling</code></pre>
<p><br>別のターミナルを開いて次のコマンドを実行しておくと、順次アップデートされていく様子を確認できます。</p>
<pre><code>watch cf app hello-cf

# または

while true;do cf app hello-cf;sleep 1;done</code></pre>
<p><br>Infoエンドポイントにアクセスして稼働しているアプリケーションのバージョンを確認してください。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.4</code></pre>
<p><br>次のコマンドでアプリケーションのRestartもRolling Updateで実施できます。</p>
<pre><code>cf restart --strategy rolling hello-cf</code></pre>
<p><code>manifest.yml</code>の変更を反映したいだけであれば<code>cf push</code>を実行しなくても次のコマンドだけで適用できます。(<code>cf push</code>よりも速いです。)<br></p>
<pre><code>cf apply-manifest
cf restart --strategy rolling hello-cf</code></pre>
<h2 is-upgraded><br>Revision</h2>
<p>Blue-Green Updateによって旧バージョンへ切り戻しができることを学びましたが、Tanzu Application Serviceのアプリケーションには<a href="https://docs.cloudfoundry.org/devguide/revisions.html" target="_blank">Revision</a>という仕組みが用意され、アプリケーションの情報を世代管理できます。Revisionの仕組みを使って簡単に旧バージョンへ切り戻す(Rollback)ことができます。</p>
<p>Apps Managerの左のメニューの&#34;Revisions&#34;をクリックしてください。</p>
<p class="image-container"><img style="width: 601.70px" src="img/441e1aa4c630f93a.png"></p>
<p>Revisionに紐づく環境変数を見ることもできます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/ddd454d7ec0fcf73.png"></p>
<p>Revision一覧は<code>cf revisions</code>コマンドでも確認できます。</p>
<pre><code>$ cf revisions hello-cf
Getting revisions for app hello-cf in org hol / space tmaki as makingx@gmail.com...

revision   description                                                 deployable   revision guid                          created at
2          New droplet deployed. New environment variables deployed.   true         94e2a30f-e679-42c2-80fd-6fad6317e3c4   2020-11-02T16:33:16Z
1          Initial revision.                                           true         98bd152e-4490-447d-80df-00699c369817   2020-11-02T16:22:14Z</code></pre>
<p><br>Revision 1を開き、&#34;REDEPLOY&#34;ボタンをクリックしてください。<br><img style="width: 601.70px" src="img/374494d434c494af.png"><br><br>Revision 1にRollbackしています。Rollback後は新たにRevision 3として扱われます。<br><br><img style="width: 601.70px" src="img/bb4eccaa33720b2f.png"></p>
<p>Revision 3がRevision 1と同じ環境変数になっていることを確認してください。<br><img style="width: 601.70px" src="img/55fdd53a1cf45fa5.png"><br></p>
<p>Infoエンドポイントにアクセスして、アプリケーションのバージョンがRollbackされていることを確認してください。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/actuator/info | jq -r .version
0.0.3</code></pre>
<p><br>ロールバックは<code>cf rollback</code>コマンドでも実行できます。<br></p>


      </google-codelab-step>
    
      <google-codelab-step label="Service BrokerでPostgreSQLサービスを作成してアクセス" duration="90">
        <p>アプリケーションが使用するデータベースのインスタンスを自動で払い出すためにService Brokerを使用します。<br>Hands-on Lab用の環境にはPostgreSQL as a Serviceである<a href="https://www.elephantsql.com" target="_blank">ElaphantSQL</a>のインスタンスを作成してくれる<a href="https://github.com/making/elephantsql-service-broker" target="_blank">Elephant SQL Service Broker</a>[2]がインストールされています。これを使用することで<code>cf</code>コマンドだけで専用のデータベースを作成できます。</p>
<h2 is-upgraded><br>アプリケーションの変更</h2>
<p>まずはアプリケーションを変更してPostgreSQLにアクセスするようにします。hello-cfディレクトリの下の<code>pom.xml</code>の<code>&lt;dependencies&gt;</code>内に次の3つの<code>&lt;deppendency&gt;</code>を追加してください。</p>
<pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
      &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.pivotal.cfenv&lt;/groupId&gt;
      &lt;artifactId&gt;java-cfenv-boot&lt;/artifactId&gt;
      &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;</code></pre>
<p><code>src/main/java/com/example/CarController.java</code>を作成し、次の内容を記述してください。</p>
<pre><code>package com.example;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.sql.PreparedStatement;
import java.util.List;

@RestController
public class CarController {

    private final JdbcTemplate jdbcTemplate;

    public CarController(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @GetMapping(path = &#34;/cars&#34;)
    public ResponseEntity&lt;?&gt; getCars() {
        final List&lt;Car&gt; cars = this.jdbcTemplate.query(&#34;SELECT id, name FROM car ORDER BY id&#34;, (rs, i) -&gt; new Car(rs.getInt(&#34;id&#34;), rs.getString(&#34;name&#34;)));
        return ResponseEntity.ok(cars);
    }

    @PostMapping(path = &#34;/cars&#34;)
    public ResponseEntity&lt;?&gt; postCars(@RequestBody Car car) {
        KeyHolder keyHolder = new GeneratedKeyHolder();
        this.jdbcTemplate.update(connection -&gt; {
            final PreparedStatement statement = connection.prepareStatement(&#34;INSERT INTO car(name) VALUES (?)&#34;, new String[]{&#34;id&#34;});
            statement.setString(1, car.getName());
            return statement;
        }, keyHolder);
        car.setId(keyHolder.getKey().intValue());
        return ResponseEntity.status(HttpStatus.CREATED).body(car);
    }

    @DeleteMapping(path = &#34;/cars/{id}&#34;)
    public ResponseEntity&lt;?&gt; deleteCar(@PathVariable(&#34;id&#34;) Integer id) {
        this.jdbcTemplate.update(&#34;DELETE FROM car WHERE id = ?&#34;, id);
        return ResponseEntity.noContent().build();
    }

    static class Car {

        public Car(Integer id, String name) {
            this.id = id;
            this.name = name;
        }

        private Integer id;

        private String name;

        public Integer getId() {
            return id;
        }

        public void setId(Integer id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}</code></pre>
<p><code>src/main/resources/db/migration/V1__init.sql</code>を作成し、次の内容を記述してください。なお、<code>src/main/resources/db/migration</code>ディレクトリは存在していないので、新規作成してください。</p>
<pre><code>CREATE TABLE car (
    id   SERIAL PRIMARY KEY,
    name VARCHAR(16)
);

INSERT INTO car(name) VALUES (&#39;Avalon&#39;);
INSERT INTO car(name) VALUES (&#39;Corolla&#39;);
INSERT INTO car(name) VALUES (&#39;Crown&#39;);
INSERT INTO car(name) VALUES (&#39;Levin&#39;);
INSERT INTO car(name) VALUES (&#39;Yaris&#39;);
INSERT INTO car(name) VALUES (&#39;Vios&#39;);
INSERT INTO car(name) VALUES (&#39;Glanza&#39;);
INSERT INTO car(name) VALUES (&#39;Aygo&#39;);</code></pre>
<p><code>src/main/resources/application.properties</code>に次の内容を記述してください。</p>
<pre><code>spring.datasource.driver-class-name=org.postgresql.Driver
# Local用のダミー設定
spring.datasource.url=jdbc:postgresql://localhost:5432/car
spring.datasource.username=${USER}
spring.datasource.password=</code></pre>
<p><br>アプリケーションをビルドしてください。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true</code></pre>
<h2 is-upgraded>サービスインスタンスの作成</h2>
<p>Service Brokerで作成されるリソースの単位をサービスインスタンスといいます。<code>cf create-service</code>コマンドでサービスインスタンスを作成できます。次のコマンドでElephantSQLのサービスインスタンスを作成してください。<br></p>
<pre><code>cf create-service elephantsql turtle car-db</code></pre>
<h2 is-upgraded>アプリケーションのデプロイ</h2>
<p><code>manifest.yml</code>の<code>services</code>にサービスインスタンス名を指定し、アプリケーションのサービスインスタンスをバインドします。<code>manifest.yml</code>を次のように変更してください。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1 # ⭐️
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  services:
  - hello
  - car-db # ⭐️
  env:
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    INFO_VERSION: 0.0.5 # ⭐️
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<p><br>アプリケーションをpushしてください。</p>
<pre><code>cf push --strategy rolling</code></pre>
<p><code>hello-cf</code>アプリにバインドされているサービスインスタンスはApps Managerから確認できます。左のメニューの&#34;Services&#34;をクリックして確認してください。</p>
<p><img style="width: 601.70px" src="img/2648c85e58b4a044.png"><br><br>デプロイしたアプリにアクセスします。</p>
<pre><code>$ curl -s https://${HOST}.apps.cf.maki.lol/cars | jq .
[
  {
    &#34;id&#34;: 1,
    &#34;name&#34;: &#34;Avalon&#34;
  },
  {
    &#34;id&#34;: 2,
    &#34;name&#34;: &#34;Corolla&#34;
  },
  {
    &#34;id&#34;: 3,
    &#34;name&#34;: &#34;Crown&#34;
  },
  {
    &#34;id&#34;: 4,
    &#34;name&#34;: &#34;Levin&#34;
  },
  {
    &#34;id&#34;: 5,
    &#34;name&#34;: &#34;Yaris&#34;
  },
  {
    &#34;id&#34;: 6,
    &#34;name&#34;: &#34;Vios&#34;
  },
  {
    &#34;id&#34;: 7,
    &#34;name&#34;: &#34;Glanza&#34;
  },
  {
    &#34;id&#34;: 8,
    &#34;name&#34;: &#34;Aygo&#34;
  }
]

$ curl -s https://${HOST}.apps.cf.maki.lol/cars -d &#34;{\&#34;name\&#34;: \&#34;Lexus\&#34;}&#34; -H &#34;Content-Type: application/json&#34; | jq .
{
  &#34;id&#34;: 9,
  &#34;name&#34;: &#34;Lexus&#34;
}

$ curl -s https://${HOST}.apps.cf.maki.lol/cars | jq .
[
  {
    &#34;id&#34;: 1,
    &#34;name&#34;: &#34;Avalon&#34;
  },
  {
    &#34;id&#34;: 2,
    &#34;name&#34;: &#34;Corolla&#34;
  },
  {
    &#34;id&#34;: 3,
    &#34;name&#34;: &#34;Crown&#34;
  },
  {
    &#34;id&#34;: 4,
    &#34;name&#34;: &#34;Levin&#34;
  },
  {
    &#34;id&#34;: 5,
    &#34;name&#34;: &#34;Yaris&#34;
  },
  {
    &#34;id&#34;: 6,
    &#34;name&#34;: &#34;Vios&#34;
  },
  {
    &#34;id&#34;: 7,
    &#34;name&#34;: &#34;Glanza&#34;
  },
  {
    &#34;id&#34;: 8,
    &#34;name&#34;: &#34;Aygo&#34;
  },
  {
    &#34;id&#34;: 9,
    &#34;name&#34;: &#34;Lexus&#34;
  }
]</code></pre>
<p><code>cf env</code>コマンドでサービスインスタンスから渡されるデータベースの接続情報を確認します。</p>
<pre><code>$ cf env hello-cf
Getting env variables for app hello-cf in org hol / space tmaki as tmaki@pivotal.io...
System-Provided:
VCAP_SERVICES: {
... (略) ...
 &#34;elephantsql&#34;: [
  {
   &#34;binding_name&#34;: null,
   &#34;credentials&#34;: {
    &#34;hostname&#34;: &#34;satao.db.elephantsql.com&#34;,
    &#34;jdbcUrl&#34;: &#34;jdbc:postgresql://satao.db.elephantsql.com:5432/fxwhicct?user=fxwhicct\u0026password=ahgpepaephpoahpeoaf00gahphapefa&#34;,
    &#34;name&#34;: &#34;fxwhicct&#34;,
    &#34;password&#34;: &#34;ahgpepaephpoahpeoaf00gahphapefa&#34;,
    &#34;port&#34;: 5432,
    &#34;uri&#34;: &#34;postgres://fxwhicct:ahgpepaephpoahpeoaf00gahphapefa@satao.db.elephantsql.com:5432/fxwhicct&#34;,
    &#34;username&#34;: &#34;fxwhicct&#34;
   },
   &#34;instance_name&#34;: &#34;car-db&#34;,
   &#34;label&#34;: &#34;elephantsql&#34;,
   &#34;name&#34;: &#34;car-db&#34;,
   &#34;plan&#34;: &#34;turtle&#34;,
   &#34;provider&#34;: null,
   &#34;syslog_drain_url&#34;: null,
   &#34;tags&#34;: [
    &#34;postgresql&#34;,
    &#34;postgres&#34;,
    &#34;elephantsql&#34;
   ],
   &#34;volume_mounts&#34;: []
  }
 ]
}
... (略) ...</code></pre>
<p><br>アプリケーションがこの接続情報を使うのために<a href="https://github.com/pivotal-cf/java-cfenv" target="_blank">java-cfenv</a>というライブラリを使いました。このライブラリはサービスインスタンスの持つ接続情報をSpring Bootのプロパティ(<code>spring.datasource.url</code>など)に自動で変換して設定します。</p>
<p><code>cf logs</code>コマンドで次のようなメッセージが出力されていることを確認してください。<code>car-db</code>サービスインスタンスから<code>spring.datasource</code>プロパティが自動設定されていることを確認できます。</p>
<pre><code>$ cf logs hello-cf --recent
...
   2020-11-03T02:38:51.02+0900 [APP/PROC/WEB/cd2b1d7a-9cf9-4948-b943-6d792c3968e0] OUT 2020-11-02 17:38:51.025  INFO 1 --- [           main] s.b.CfDataSourceEnvironmentPostProcessor : Setting spring.datasource properties from bound service [car-db]
...</code></pre>
<p><code>cf logs</code>コマンドで次のようなメッセージが出力されていることを確認してください。</p>
<pre><code>$ cf logs hello-cf --recent
...
   2020-07-23T17:14:28.27+0900 [APP/PROC/WEB/0] OUT 2020-07-23 08:14:28.272  INFO 13 --- [           main] o.c.reconfiguration.CloudServiceUtils    : &#39;dataSource&#39; bean of type with &#39;javax.sql.DataSource&#39; reconfigured with &#39;car-db&#39; bean
...</code></pre>
<p><code>car-db</code>サービスインスタンスの情報から<code>DataSource</code>インスタンスを作成したことを知らせています。</p>
<p><code>manifest.yml</code>に次の環境変数を設定し、Auto-Reconfigurationを無効にします。また、環境変数<code>SPRING_DATASOURCE_HIKARI_MAXIMUMPOOLSIZE</code>を設定し、Connection Poolの最大接続数を明示的に設定します。これはElephantSQLサービスのturtleプランの最大接続数が5であり、rolling update中にこの値を超えた接続が行われないようにするためです。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  services:
  - hello
  - car-db
  env:
    # ⭐️⭐️⭐️
    SPRING_DATASOURCE_HIKARI_MAXIMUMPOOLSIZE: 2
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    INFO_VERSION: 0.0.6 # ⭐️
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<p><code>cf push</code>してください。</p>
<pre><code>cf push</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Oracle Databaseにアクセス" duration="15">
        <p>(このセクションは説明のみで演習は行いません)</p>
<p>Oracle DatabaseのようにMarketplaceにServiceが登録されてないデータベースにアクセスしたい場合は、<strong>Provision済みの情報</strong>をUser Provided ServiceまたはCredhub Service Brokerに接続情報を登録すれば良いです。</p>
<h2 is-upgraded>Connection Type: SIDの場合</h2>
<p>SIDで接続する場合は、次の形式であればjava-cfenvが自動でSpring Bootのプロパティに設定してくれます。</p>
<pre><code># User Provided Serviceの場合
cf create-user-provided-service car-db -p &#39;{&#34;url&#34;:&#34;oracle://scott:tiger@oracle.example.com:1521/CARCDB&#34;}&#39;</code></pre>
<pre><code># Credhub Service Brokerの場合
cf create-service credhub default car-db -c &#39;{&#34;url&#34;:&#34;oracle://scott:tiger@oracle.example.com:1521/CARCDB&#34;}&#39;</code></pre>
<p>PostgreSQLの場合と<code>manfeifest.yml</code>に変更はありません。<br></p>
<h2 is-upgraded>Connection Type: Service Nameの場合</h2>
<p>Service Nameで接続する場合は、java-cfenvが現時点(July 2020)で対応していないので、java-cfenvは使用しません。次の形式でServiceに接続情報を設定します。</p>
<pre><code># User Provided Serviceの場合
cf create-user-provided-service car-db -p &#39;{&#34;username&#34;:&#34;scott&#34;, &#34;password&#34;:&#34;tiger&#34;, &#34;jdbcUrl&#34;:&#34;jdbc:oracle:thin:@//oracle.example.com:1521/CARCDB&#34;}&#39;</code></pre>
<pre><code># Credhub Service Brokerの場合
cf create-service credhub default car-db -c &#39;{&#34;username&#34;:&#34;scott&#34;, &#34;password&#34;:&#34;tiger&#34;, &#34;jdbcUrl&#34;:&#34;jdbc:oracle:thin:@//oracle.example.com:1521/CARCDB&#34;}&#39;</code></pre>
<p><code>manifest.yml</code>は次のように設定してください。<strong>また、</strong><strong><code>pom.xml</code></strong><strong>からjava-cfenvの</strong><strong><code>&lt;dependency&gt;</code></strong><strong>を削除してください。</strong></p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  services:
  - hello
  - car-db
  env:
    # ⭐️⭐️⭐️
    SPRING_DATASOURCE_USERNAME: ${vcap.services.car-db.credentials.username}
    SPRING_DATASOURCE_PASSWORD: ${vcap.services.car-db.credentials.password}
    SPRING_DATASOURCE_URL: ${vcap.services.car-db.credentials.jdbcUrl}
    SPRING_DATASOURCE_HIKARI_MAXIMUMPOOLSIZE: 2
    MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: info,health,env,prometheus
    INFO_VERSION: 0.0.6
    INFO_JAVA_VERSION: ${java.runtime.version}
    INFO_JAVA_VENDOR: ${java.vm.vendor}
    API_KEY: ${vcap.services.hello.credentials.api-key}</code></pre>
<h2 is-upgraded>アプリケーションの変更</h2>
<p>PostgreSQLではなくOracle DBを使うようにアプリケーションを以下のファイルを変更します。</p>
<p><code>pom.xml</code></p>
<pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;
      &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;

&lt;!-- PostgreSQL Driverは不要
    &lt;dependency&gt;
      &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
--&gt;

&lt;!-- Connection Type: Service Nameの場合、java-cfenv-bootを除外
        &lt;dependency&gt;
            &lt;groupId&gt;io.pivotal.cfenv&lt;/groupId&gt;
            &lt;artifactId&gt;java-cfenv-boot&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
--&gt;</code></pre>
<p><code><br>src/main/resources/application.properties</code></p>
<pre><code># Local用のダミー設定
spring.datasource.username=scott
spring.datasource.password=tiger
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# 対象のスキーマが空でない場合は、現状をversion 0としてDBマイグレーション管理する
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=0
spring.flyway.baseline-description=Reset baseline</code></pre>
<p><code><br>src/main/resources/db/migration/V1__init.sql</code></p>
<pre><code>CREATE TABLE car (
    id   NUMBER GENERATED ALWAYS AS IDENTITY,
    name VARCHAR2(16)
);

INSERT INTO car(name) VALUES (&#39;Avalon&#39;);
INSERT INTO car(name) VALUES (&#39;Corolla&#39;);
INSERT INTO car(name) VALUES (&#39;Crown&#39;);
INSERT INTO car(name) VALUES (&#39;Levin&#39;);
INSERT INTO car(name) VALUES (&#39;Yaris&#39;);
INSERT INTO car(name) VALUES (&#39;Vios&#39;);
INSERT INTO car(name) VALUES (&#39;Glanza&#39;);
INSERT INTO car(name) VALUES (&#39;Aygo&#39;);</code></pre>
<p><br>アプリケーションをビルドし、pushしてください。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true
cf push --strategy rolling</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Prometheusを使ったメトリクス収集" duration="60">
        <p>TBD</p>


      </google-codelab-step>
    
      <google-codelab-step label="Taskでバッチ処理を実行" duration="75">
        <p>Cloud FoundryはWebアプリケーションのような常駐アプリケーション(Long Running Process)だけでなく短命な<a href="https://docs.cloudfoundry.org/devguide/using-tasks.html" target="_blank">Task</a>も実行できます。Task機能を用いてバッチ処理を実行します。<a href="https://spring.io/projects/spring-batch" target="_blank">Spring Batch</a>を使用して、簡単なバッチ処理をデプロイします。</p>
<h2 is-upgraded>Taskの実行</h2>
<p>まずはCloud FoundryのTask機能を試してみます。<code>cf run-task</code>コマンドでシンプルなコマンドを実行しましょう。</p>
<pre><code>$ cf run-task hello-cf -c &#34;ls -la&#34;
Creating task for app hello-cf in org hol / space tmaki as makingx@gmail.com...
Task has been submitted successfully for execution.
OK

task name:   fa958a46
task id:     1</code></pre>
<p>Taskの出力は<code>cf logs</code>で確認できます。</p>
<pre><code>$ cf logs hello-cf
Retrieving logs for app hello-cf in org hol / space tmaki as makingx@gmail.com...

   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT total 84
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Nov  2 17:50 .
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Nov  2 17:50 ..
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:11 bin
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Apr 24  2018 boot
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   3 root root 4096 Jan  1  1980 cnb
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   5 root root  360 Nov  2 17:50 dev
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:19 etc
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:19 home
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxrwsrwx   1 root cnb  4096 Jan  1  1980 layers
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:10 lib
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Sep 21 17:16 lib64
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Sep 21 17:14 media
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Sep 21 17:14 mnt
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Sep 21 17:14 opt
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT dr-xr-xr-x 270 root root    0 Nov  2 17:50 proc
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwx------   2 root root 4096 Sep 21 17:17 root
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Nov  2 17:50 run
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:10 sbin
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   2 root root 4096 Sep 21 17:14 srv
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT dr-xr-xr-x  13 root root    0 Nov  1 11:09 sys
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxrwxrwt   2 root root 4096 Sep 21 17:17 tmp
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:19 usr
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxr-xr-x   1 root root 4096 Oct 14 18:19 var
   2020-11-03T02:50:41.01+0900 [TASK/8eef52da-85f8-421e-93d6-baedfd3457b2] OUT drwxrwsrwx   5 cnb  cnb  4096 Jan  1  1980 workspace</code></pre>
<h2 is-upgraded>Spring Batchアプリケーション作成</h2>
<p>次はSpring Batchを使った本格的なバッチアプリケーションを作成しましょう。<br>Spring Batchでは&#34;入力 -&gt; 加工 -&gt; 出力&#34;の処理をそれぞれ<code>ItemReader</code>、<code>ItemProcessor</code>、<code>ItemWriter</code>で行います。今回はCSVファイルを読み込み、データを加工し、データベースに保存する簡単なバッチ処理を実装します[3]。</p>
<p class="image-container"><img style="width: 601.70px" src="img/a1fbd68648325e1e.png"></p>
<p>まずはSpring Batchを使ったアプリケーションの雛形を作成します。<br></p>
<pre><code>cd ..
curl https://start.spring.io/starter.tgz \
    -d artifactId=billing-job \
    -d baseDir=billing-job \
    -d packageName=com.example \
    -d dependencies=batch,postgresql,configuration-processor \
    -d applicationName=BillingJobApplication | tar -xzvf -</code></pre>
<pre><code>cd billing-job</code></pre>
<p><code><br>pom.xml</code>の<code>&lt;dependencies&gt;</code>内に次の3つの<code>&lt;deppendency&gt;</code>を追加してください。</p>
<pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;io.pivotal.cfenv&lt;/groupId&gt;
      &lt;artifactId&gt;java-cfenv-boot&lt;/artifactId&gt;
      &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;</code></pre>
<p>① <code>src/main/java/com/example/Bill.jav</code>aを作成し、次の内容を記述してください。</p>
<pre><code>package com.example;

import java.math.BigDecimal;
import java.math.RoundingMode;

public class Bill {
    private final Long id;
    private final String firstName;
    private final String lastName;
    private final Long dataUsage;
    private final Long minutes;
    private final BigDecimal billAmount;

    public static Bill fromUsage(Usage usage) {
        final BigDecimal billAmount = calcBillAmount(usage.getDataUsage(), usage.getMinutes());
        return new Bill(usage.getId(), usage.getFirstName(), usage.getLastName(), usage.getDataUsage(), usage.getMinutes(), billAmount);
    }

    public Bill(Long id, String firstName, String lastName, Long dataUsage, Long minutes, BigDecimal billAmount) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.dataUsage = dataUsage;
        this.minutes = minutes;
        this.billAmount = billAmount;
    }

    public static BigDecimal calcBillAmount(Long dataUsage, Long minutes) {
        // dataUsage * 0.001 + usageMinutes * 0.01
        return BigDecimal.valueOf(dataUsage).multiply(new BigDecimal(&#34;0.001&#34;))
                .add(BigDecimal.valueOf(minutes).multiply(new BigDecimal(&#34;0.01&#34;)))
                .setScale(2, RoundingMode.FLOOR);
    }

    public Long getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public Long getDataUsage() {
        return dataUsage;
    }

    public Long getMinutes() {
        return minutes;
    }

    public BigDecimal getBillAmount() {
        return billAmount;
    }
}</code></pre>
<p>② <code>src/main/java/com/example/Usage.java</code>を作成し、次の内容を記述してください。</p>
<pre><code>package com.example;

public class Usage {
    private final Long id;
    private final String firstName;
    private final String lastName;
    private final Long minutes;
    private final Long dataUsage;

    public Usage(Long id, String firstName, String lastName, Long minutes, Long dataUsage) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.minutes = minutes;
        this.dataUsage = dataUsage;
    }

    public Long getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public Long getMinutes() {
        return minutes;
    }

    public Long getDataUsage() {
        return dataUsage;
    }
}</code></pre>
<p>③ <code>src/main/java/com/example/BillingConfig.java</code>を作成し、次の内容を記述してください。</p>
<pre><code>package com.example;

import javax.sql.DataSource;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;

@Configuration
@EnableBatchProcessing
public class BillingConfig {
        private final JobBuilderFactory jobBuilderFactory;

        private final StepBuilderFactory stepBuilderFactory;


        public BillingConfig(JobBuilderFactory jobBuilderFactory,
                        StepBuilderFactory stepBuilderFactory) {
                this.jobBuilderFactory = jobBuilderFactory;
                this.stepBuilderFactory = stepBuilderFactory;
        }

        @Bean
        public Job billingJob(ItemReader&lt;Usage&gt; itemReader, ItemProcessor&lt;Usage, Bill&gt; itemProcessor, ItemWriter&lt;Bill&gt; itemWriter) {
                final Step step = this.stepBuilderFactory.get(&#34;BilliProcessing&#34;)
                                .&lt;Usage, Bill&gt;chunk(1000)
                                .reader(itemReader)
                                .processor(itemProcessor)
                                .writer(itemWriter)
                                .build();
                return this.jobBuilderFactory.get(&#34;BillingJob&#34;)
                                .incrementer(new RunIdIncrementer())
                                .start(step)
                                .build();
        }

        @Bean
        @StepScope
        public FlatFileItemReader&lt;Usage&gt; usageItemReader(@Value(&#34;#{jobParameters[&#39;usageInfoFile&#39;]}&#34;) Resource usageInfoFile) {
                return new FlatFileItemReaderBuilder&lt;Usage&gt;()
                                .name(&#34;UsageItemReader&#34;)
                                .resource(usageInfoFile)
                                .delimited()
                                .names(&#34;id&#34;, &#34;firstName&#34;, &#34;lastName&#34;, &#34;minutes&#34;, &#34;dataUsage&#34;)
                                .fieldSetMapper(fs -&gt; new Usage(fs.readLong(&#34;id&#34;),
                                                fs.readString(&#34;firstName&#34;),
                                                fs.readString(&#34;lastName&#34;),
                                                fs.readLong(&#34;minutes&#34;),
                                                fs.readLong(&#34;dataUsage&#34;)))
                                .linesToSkip(1)
                                .build();
        }

        @Bean
        public ItemProcessor&lt;Usage, Bill&gt; billItemProcessor() {
                return new ItemProcessor&lt;Usage, Bill&gt;() {
                        @Override
                        public Bill process(Usage usage) throws Exception {
                                return Bill.fromUsage(usage);
                        }
                };
        }

        @Bean
        public ItemWriter&lt;Bill&gt; jdbcBillWriter(DataSource dataSource) {
                return new JdbcBatchItemWriterBuilder&lt;Bill&gt;()
                                .beanMapped()
                                .dataSource(dataSource)
                                .sql(&#34;INSERT INTO BILL_STATEMENTS (id, first_name, last_name, minutes, data_usage,bill_amount) VALUES (:id, :firstName, :lastName, :minutes, :dataUsage, :billAmount)&#34;)
                                .build();
        }
}</code></pre>
<p>④ <code>src/main/resources/application.properties</code>に次の内容を記述してください。</p>
<pre><code>spring.datasource.initialization-mode=always
spring.batch.initialize-schema=always
spring.datasource.driver-class-name=org.postgresql.Driver

# Local用のダミー設定
spring.datasource.url=jdbc:postgresql://localhost:5432/billing
spring.datasource.username=${USER}
spring.datasource.password=

# 余分なログを出力しない
logging.level.root=WARN
logging.level.com.example=INFO
logging.level.org.springframework.batch=INFO
logging.level.org.springframework.batch.core.step.tasklet.TaskletStep=DEBUG</code></pre>
<p>⑤ <code>src/main/resources/schema.sql</code>を作成し、次の内容を記述してください。</p>
<pre><code>CREATE TABLE IF NOT EXISTS BILL_STATEMENTS
(
    id          INT,
    first_name  VARCHAR(50),
    last_name   VARCHAR(50),
    minutes     INT,
    data_usage  INT,
    bill_amount DECIMAL(10, 2)
);</code></pre>
<p>⑥ <code>src/main/resources/usageinfo.csv</code>を作成し、次の内容を記述してください。(<strong>ファイルの末尾に空行を入れないでください</strong>)</p>
<pre><code>id,firstName,lastName,minutes,dataUsage
1,jane,doe,500,1000
2,john,doe,550,1500
3,melissa,smith,600,1550
4,michael,smith,650,1500
5,mary,jones,700,1500</code></pre>
<p>次のコマンドでアプリケーションをビルドします。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true</code></pre>
<p>バッチ処理で使用するデータベースのサービスインスタンスを作成します。</p>
<pre><code>cf create-service elephantsql turtle billing-db</code></pre>
<p><code>manifest.yml</code>を作成し、次の内容を記述してください。バッチはWebアプリとして起動する必要がないため<code>instances</code>は<code>0</code>で良いです。またRouteのアサインが不要であるため、<code>no-route: true</code>を設定します。</p>
<pre><code>applications:
- name: billing-job
  # ⭐️⭐️⭐️
  no-route: true
  instances: 0 # ⭐️⭐️⭐️
  path: target/billing-job-0.0.1-SNAPSHOT.jar
  services:
  - billing-db</code></pre>
<p><code>cf push</code>でアプリケーションをデプロイしてください。</p>
<pre><code>cf push</code></pre>
<p>なお、<code>--task</code>オプションをつけて<code>cf push</code>する場合は、<code>instances: 0</code>と<code>no-route: true</code>が設定されるので<code>manifest.yml</code>に設定する必要はありません。</p>
<pre><code>cf push --task</code></pre>
<p>Taskとしてバッチ処理を実行する前にログを追跡しましょう。</p>
<pre><code>cf logs billing-job </code></pre>
<p><code>cf run-task</code>コマンドでSpring BatchアプリケーションをTaskとして実行</p>
<pre><code>cf run-task billing-job -m 128m -c &#34;/layers/paketo-buildpacks_bellsoft-liberica/jre/bin/java -cp /workspace org.springframework.boot.loader.JarLauncher usageInfoFile=classpath:usageinfo.csv&#34;</code></pre>
<p>次のようなログが出力されることを確認してください。</p>
<pre><code>   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT .   ____          _            __ _ _
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT ( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT &#39;  |____| .__|_| |_|_| |_\__, | / / / /
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT =========|_|==============|___/=/_/_/_/
   2020-11-03T14:18:41.35+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT :: Spring Boot ::        (v2.3.5.RELEASE)
   2020-11-03T14:18:41.47+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:41.471  INFO 6 --- [           main] com.example.BillingJobApplication        : Starting BillingJobApplication v0.0.1-SNAPSHOT on billing-job-tmaki-6b0a59d3-l7nz7 with PID 6 (/workspace/BOOT-INF/classes started by cnb in /)
   2020-11-03T14:18:41.47+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:41.475  INFO 6 --- [           main] com.example.BillingJobApplication        : No active profile set, falling back to default profiles: default
   2020-11-03T14:18:44.63+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:44.637  INFO 6 --- [           main] o.s.b.c.r.s.JobRepositoryFactoryBean     : No database type set, using meta data indicating: POSTGRES
   2020-11-03T14:18:44.67+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:44.670  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : No TaskExecutor has been set, defaulting to synchronous executor.
   2020-11-03T14:18:44.84+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:44.840  INFO 6 --- [           main] com.example.BillingJobApplication        : Started BillingJobApplication in 4.23 seconds (JVM running for 4.903)
   2020-11-03T14:18:45.96+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:45.967  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=BillingJob]] launched with the following parameters: [{run.id=1, usageInfoFile=classpath:usageinfo.csv}]
   2020-11-03T14:18:46.74+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:46.742  INFO 6 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [BilliProcessing]
   2020-11-03T14:18:47.28+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:47.285 DEBUG 6 --- [           main] o.s.batch.core.step.tasklet.TaskletStep  : Applying contribution: [StepContribution: read=5, written=5, filtered=0, readSkips=0, writeSkips=0, processSkips=0, exitStatus=EXECUTING]
   2020-11-03T14:18:47.34+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:47.343 DEBUG 6 --- [           main] o.s.batch.core.step.tasklet.TaskletStep  : Saving step execution before commit: StepExecution: id=1, version=1, name=BilliProcessing, status=STARTED, exitStatus=EXECUTING, readCount=5, filterCount=0, ⭐️⭐️⭐️writeCount=5 readSkipCount=0, writeSkipCount=0, processSkipCount=0, commitCount=1, rollbackCount=0, exitDescription=
   2020-11-03T14:18:47.60+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:47.609  INFO 6 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [BilliProcessing] executed in 867ms
   2020-11-03T14:18:48.08+0900 [TASK/685d014b-ac7a-4018-8130-9ef0161a46ae] OUT 2020-11-03 05:18:48.085  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=BillingJob]] completed with the following parameters: [{run.id=1, usageInfoFile=classpath:usageinfo.csv}] and the following status: [COMPLETED] in 1s889ms</code></pre>
<p>ログからデータを5件処理したことがわかります。<br></p>
<aside class="warning"><p>Note: Exit <code>status 137 (out of memory)</code>が発生する場合は<code>-m 128m</code>を<code>-m 256m</code>に変更して実行してください。</p>
</aside>
<p><br>もう少し多くのデータを処理しましょう。次は入力データファイルをHTTP経由で取得します。Spring Batchアプリケーションのコマンド引数を変更して<code>cf run-task</code>を実行します。</p>
<pre><code>cf run-task billing-job -m 128m -c &#34;/layers/paketo-buildpacks_bellsoft-liberica/jre/bin/java -cp /workspace org.springframework.boot.loader.JarLauncher usageInfoFile=https://github.com/making/fakedata/raw/master/usageinfo/usageinfo-10000-en.csv&#34;</code></pre>
<p>次のようなログが出力されることを確認してください。</p>
<pre><code>   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT .   ____          _            __ _ _
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT ( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT &#39;  |____| .__|_| |_|_| |_\__, | / / / /
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT =========|_|==============|___/=/_/_/_/
   2020-11-03T14:20:41.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT :: Spring Boot ::        (v2.3.5.RELEASE)
   2020-11-03T14:20:41.70+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:41.698  INFO 6 --- [           main] com.example.BillingJobApplication        : Starting BillingJobApplication v0.0.1-SNAPSHOT on billing-job-tmaki-12359d51-f4bhc with PID 6 (/workspace/BOOT-INF/classes started by cnb in /)
   2020-11-03T14:20:41.70+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:41.701  INFO 6 --- [           main] com.example.BillingJobApplication        : No active profile set, falling back to default profiles: default
   2020-11-03T14:20:45.11+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:45.114  INFO 6 --- [           main] o.s.b.c.r.s.JobRepositoryFactoryBean     : No database type set, using meta data indicating: POSTGRES
   2020-11-03T14:20:45.14+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:45.147  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : No TaskExecutor has been set, defaulting to synchronous executor.
   2020-11-03T14:20:45.25+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:45.253  INFO 6 --- [           main] com.example.BillingJobApplication        : Started BillingJobApplication in 4.478 seconds (JVM running for 5.091)
   2020-11-03T14:20:46.58+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:46.581  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=BillingJob]] launched with the following parameters: [{run.id=2, usageInfoFile=https://github.com/making/fakedata/raw/master/usageinfo/usageinfo-10000-en.csv}]
   2020-11-03T14:20:47.37+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:47.379  INFO 6 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [BilliProcessing]
   2020-11-03T14:20:49.47+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:49.473 DEBUG 6 --- [           main] o.s.batch.core.step.tasklet.TaskletStep  : Applying contribution: [StepContribution: read=1000, written=1000, filtered=0, readSkips=0, writeSkips=0, processSkips=0, exitStatus=EXECUTING]
   2020-11-03T14:20:49.52+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:49.527 DEBUG 6 --- [           main] o.s.batch.core.step.tasklet.TaskletStep  : Saving step execution before commit: StepExecution: id=2, version=1, name=BilliProcessing, status=STARTED, exitStatus=EXECUTING, readCount=1000, filterCount=0, writeCount=1000 readSkipCount=0, writeSkipCount=0, processSkipCount=0, commitCount=1, rollbackCount=0, exitDescription=
(略)
   2020-11-03T14:20:54.31+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:54.311 DEBUG 6 --- [           main] o.s.batch.core.step.tasklet.TaskletStep  : Saving step execution before commit: StepExecution: id=2, version=11, name=BilliProcessing, status=STARTED, exitStatus=EXECUTING, readCount=10000, filterCount=0, ⭐️⭐️⭐️writeCount=10000 readSkipCount=0, writeSkipCount=0, processSkipCount=0, commitCount=11, rollbackCount=0, exitDescription=
   2020-11-03T14:20:54.57+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:54.574  INFO 6 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [BilliProcessing] executed in 7s195ms
   2020-11-03T14:20:55.04+0900 [TASK/76062756-f747-40e6-bc1d-0c1ecab4128f] OUT 2020-11-03 05:20:55.044  INFO 6 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=BillingJob]] completed with the following parameters: [{run.id=2, usageInfoFile=https://github.com/making/fakedata/raw/master/usageinfo/usageinfo-10000-en.csv}] and the following status: [COMPLETED] in 8s200ms</code></pre>
<p>Taskの実行履歴は<code>cf tasks</code>コマンドで確認できます。</p>
<pre><code>$ cf tasks billing-job
Getting tasks for app billing-job in org hol / space tmaki as makingx@gmail.com...

id   name       state       start time                      command
2    12359d51   SUCCEEDED   Tue, 03 Nov 2020 05:20:26 UTC   /layers/paketo-buildpacks_bellsoft-liberica/jre/bin/java -cp /workspace org.springframework.boot.loader.JarLauncher usageInfoFile=https://github.com/making/fakedata/raw/master/usageinfo/usageinfo-10000-en.csv
1    6b0a59d3   SUCCEEDED   Tue, 03 Nov 2020 05:18:24 UTC   /layers/paketo-buildpacks_bellsoft-liberica/jre/bin/java -cp /workspace org.springframework.boot.loader.JarLauncher usageInfoFile=classpath:usageinfo.csv</code></pre>
<p>Apps ManagerからもTaskの確認・実行を行えます。左のメニューの&#34;Tasks&#34;をクリックして確認してください。</p>
<p class="image-container"><img style="width: 601.70px" src="img/10893596e6a88d58.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="その他Cloud Nativeなアプリにするための諸々の考慮ポイント" duration="60">
        <h2 is-upgraded>Healthcheck</h2>
<p>アプリケーションが起動しているかどうかの判断はデフォルトでport(8080)のヘルスチェックで確認されます。portはlistenしていてもhttpレベルは機能していないという状況でリクストが来ることを防ぐため、ヘルスチェックタイプをhttpに変更することでより安全なチェックになります。</p>
<p><a href="https://docs.pivotal.io/platform/application-service/2-8/devguide/deploy-apps/manifest-attributes.html#health-check-http-endpoint" target="_blank">https://docs.pivotal.io/platform/application-service/2-8/devguide/deploy-apps/manifest-attributes.html#health-check-http-endpoint</a></p>
<p><code>manifest.yml</code>に<code>health-check-type</code>、<code>health-check-http-endpoint</code>を設定してください。</p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  # ⭐️⭐️⭐️
  health-check-type: http
  health-check-http-endpoint: /actuator/health
# 以下略...</code></pre>
<p>このヘルスチェックエンドポイントはアプリケーションが生きているか(liveness)及びアプリケーションがリクエストを受け付けて良いか(readiness)を確認するために、定期的にアクセスされます。このエンドポイントがエラーを返すと、リクエストが遮断され、コンテナが再作成されます。このような用途で使われるヘルスチェックの結果には<strong>外部サービスの状態(データベースや外部APIの利用可否)を含めるべきではありません</strong>。一般的に外部サービスはコンテナを再作成しても、状況が改善しないためです。外部サービスに障害がある場合は、コンテナを再作成するよりもアプリケーション側でエラーハンドリングした方が良いです。<br><code>/actuator/health</code>エンドポイントは<strong>外部サービスの状態を含めます。</strong>そのため、今回の用途には実は適していません。代わりに<code>/actuator/info</code>エンドポイントを使った方が良いです。</p>
<p>Spring Boot 2.3からはアプリケーションの<strong>内部状態のみをチェック</strong>して、livenessとreadinessの結果を返すエンドポイント(<code>/actuator/health/liveness</code>及び<code>/actuator/health/readiness</code>)を使えるようになりました。<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes</a></p>
<p>Tanzu Application Service (Cloud Foundry)ではlivenessとreadinessのチェックを別々に行いことができないため、設定するならば<code>/actuator/health/readiness</code>を使うと良いです。livenessとreadinessのチェックを有効にする場合は次の環境変数を設定する必要があります。</p>
<ul>
<li><code>MANAGEMENT_HEALTH_PROBES_ENABLED: true</code> (Spring Boot 2.30 - 2.3.1)</li>
<li>M<code>ANAGEMENT_ENDPOINT_HEALTH_PROBES_ENABLED: true</code> (Spring Boot 2.3.2〜)<br></li>
</ul>
<aside class="warning"><p>Note: Spring Boot 2.3.2ではlivenessとreadinessのチェックが404エラーを返す<a href="https://github.com/spring-projects/spring-boot/issues/22562" target="_blank">バグ</a>があるので利用できません。2.3.1または2.3.3以降で試してください。</p>
</aside>
<p><code>manifest.yml</code>の変更は次のようになります。<br></p>
<pre><code>applications:
- name: hello-cf
  random-route: true
  instances: 1
  memory: 768m
  path: target/hello-cf-0.0.1-SNAPSHOT.jar
  health-check-type: http
  health-check-http-endpoint: /actuator/health/readiness # ⭐️
# 略...
  env:
    # ⭐️⭐️⭐️
    MANAGEMENT_ENDPOINT_HEALTH_PROBES_ENABLED: true
# 略...</code></pre>
<p>あるいは<code>application.properties</code>に</p>
<pre><code>management.endpoint.health.probes.enabled=true</code></pre>
<p>を設定してください。</p>
<h2 is-upgraded>Graceful Shutdown</h2>
<p><strong>TODO </strong>TAS4K8sでの使用確認</p>
<p>Tanzu Application Service (Cloud Foundry)ではアプリケーションの停止させるフローは</p>
<ol type="1" start="1">
<li><code>SIGTERM</code>シグナルを送信 (= Ctrl+Cと同等)</li>
<li>(10秒経っても終了しない場合)<code>SIGKILL</code>シグナルを送信</li>
</ol>
<p>となります。</p>
<p><a href="https://docs.pivotal.io/platform/application-service/2-8/devguide/deploy-apps/app-lifecycle.html#shutdown" target="_blank">https://docs.pivotal.io/platform/application-service/2-8/devguide/deploy-apps/app-lifecycle.html#shutdown</a></p>
<p>1.と2.の間に最大10秒間の後処理が行えます。<br>Spring Bootアプリのデフォルトの挙動は<code>SIGTERM</code>シグナルを受信すると処理中のリクエストの中断終了処理に入ります。</p>
<p>Spring Boot 2.3からは<code>SIGTERM</code>シグナルを受信すると、新規リクエストは受け付けないが、処理中のリクエストは完了するまで待つGraceful Shutdownがサポートされました。<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-graceful-shutdown" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-graceful-shutdown</a></p>
<p>Graceful Shutdownを有効にする場合、<code>manifest.yml</code>の変更は次のようになります。<br></p>
<pre><code>applications:
- name: hello-cf
# 略...
  env:
    # ⭐️⭐️⭐️
    SERVER_SHUTDOWN: graceful
    SPRING_LIFECYCLE_TIMEOUTPERSHUTDOWNPHASE: 10s
# 略...</code></pre>
<p>あるいは<code>application.properties</code>に</p>
<pre><code>server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=10s</code></pre>
<p>を設定してください。</p>
<h2 is-upgraded>複数行のログを一行にまとめる</h2>
<p>ログや例外のスタックトレースが複数行に分かれる場合、転送先でログを検索し辛くなります。複数のログは一行にまとめた方が転送後は便利です。次の環境変数を設定すれば、一行にまとまります。</p>
<pre><code>applications:
- name: hello-cf
# 略...
  env:
    # ⭐️⭐️⭐️
    LOGGING_EXCEPTION_CONVERSION_WORD: &#34;\t%replace(%replace(%xEx){&#39;\n&#39;,&#39;@n@&#39;}){&#39;\t&#39;,&#39;    &#39;}%nopex&#34;
    LOGGING_PATTERN_CONSOLE: &#34;%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${logging.pattern.level:%5p}) %clr(${PID: }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %replace(%m){&#39;\n&#39;,&#39;@n@&#39;}${logging.exception-conversion-word:%wEx}%n&#34;
# 略...</code></pre>
<aside class="special"><p>Note: 上記設定では改行コード(<code>\n</code>)を<code>@n@</code>に変換しています。ログを転送する先で<code>@n@</code>を<code>\n</code>に戻すとより良いです。</p>
</aside>
<p>別解としてはログの形式をJSONに変更して、構造化ログとして転送しても良いです。この場合は<a href="https://github.com/elastic/ecs-logging-java" target="_blank">ecs-logging-java</a>が利用できます。<br>Spring Bootアプリで使う場合は<a href="https://github.com/elastic/ecs-logging-java/blob/master/logback-ecs-encoder/README.md" target="_blank">こちら</a>を参考にしてください。</p>
<h2 is-upgraded>ログにTrace IDを含める &amp; Trace IDを伝播させる</h2>
<p>TBD</p>
<p><code>pom.xml</code></p>
<pre><code>  &lt;properties&gt;
    &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;!-- ⭐️⭐️⭐️ --&gt;
    &lt;spring-cloud.version&gt;Hoxton.SR8&lt;/spring-cloud.version&gt;
  &lt;/properties&gt;</code></pre>
<pre><code>  &lt;dependencies&gt;
    &lt;!-- ⭐️⭐️⭐️ --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- 略 --&gt;
  &lt;/dependencies&gt;
  &lt;!-- ⭐️⭐️⭐️ --&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;</code></pre>
<p><code>src/main/java/com/example/ApiProperties.java</code></p>
<pre><code>package com.example;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &#34;api&#34;)
public class ApiProperties {

        private String key = &#34;SECRET&#34;;

        private String backendUrl; // ⭐️⭐️⭐️

        public String getKey() {
                return key;
        }

        public void setKey(String key) {
                this.key = key;
        }

       // ⭐️⭐️⭐️
        public String getBackendUrl() {
                return backendUrl;
        }

        public void setBackendUrl(String backendUrl) {
                this.backendUrl = backendUrl;
        }
}</code></pre>
<p><code>src/main/java/com/example/FrontController.java</code></p>
<pre><code>package com.example;

import com.fasterxml.jackson.databind.JsonNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class FrontController {
        private final RestTemplate restTemplate;

        private final Logger log = LoggerFactory.getLogger(FrontController.class);

        public FrontController(RestTemplateBuilder builder, ApiProperties props) {
                this.restTemplate = builder.rootUri(props.getBackendUrl()).build();
        }

        @GetMapping(path = &#34;/front&#34;)
        public JsonNode front() {
                log.info(&#34;Calling backend...&#34;);
                return this.restTemplate.getForObject(&#34;/&#34;, JsonNode.class);
        }
}</code></pre>
<p><code>src/main/resources/application.properties</code>に</p>
<pre><code>spring.application.name=hello-cf</code></pre>
<p>を追記してください。</p>
<p><code>manifest.yml</code></p>
<pre><code># ...
  env:
  # ...
    API_BACKENDURL: https://demo-api.apps.cf.maki.lol</code></pre>
<p>次のコマンドでアプリケーションをビルドとpushをします。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true
cf push</code></pre>
<p>次のエンドポイントに何回かアクセスしてください。</p>
<pre><code>curl -sv https://${HOST}.apps.cf.maki.lol/front | jq .</code></pre>
<h2 is-upgraded>ZipkinにTraceデータを送信する</h2>
<p>TBD</p>
<pre><code>  &lt;dependencies&gt;
    &lt;!-- ⭐️⭐️⭐️ --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- 略 --&gt;
  &lt;/dependencies&gt;</code></pre>
<p><code>src/main/resources/application.properties</code>に</p>
<pre><code>spring.sleuth.sampler.rate=30</code></pre>
<p>を設定してください。<br></p>
<pre><code>applications:
- name: hello-cf
# 略...
  env:
    # ⭐️⭐️⭐️
    SPRING_ZIPKIN_BASE_URL: https://zipkin.apps.cf.maki.lol
    SPRING_ZIPKIN_SERVICE_NAME: ${vcap.application.organization_name}:${vcap.application.space_name}:${vcap.application.application_name}
    SPRING_SLEUTH_WEB_ADDITIONALSKIPPATTERN: /actuator.*|/cloudfoundryapplication.*
# 略...</code></pre>
<p>次のコマンドでアプリケーションをビルドとpushをします。</p>
<pre><code>./mvnw clean package -Dmaven.test.skip=true
cf push</code></pre>
<p>次のエンドポイントに何回かアクセスしてください。</p>
<pre><code>curl -sv https://${HOST}.apps.cf.maki.lol/front | jq .</code></pre>
<p><a href="https://zipkin.apps.dev.example.com" target="_blank">https://zipkin.apps.cf.maki.lol</a> にアクセスしてください。</p>
<p>チーム専用のZipkin Serverが欲しい場合、別途デプロイ可能です。</p>
<p><code>zipkin</code>ディレクトリを作成して、その下で<code>manifest.yml</code>を作成し、次の内容を記述してください。</p>
<pre><code>applications:
- name: zipkin
  memory: 1g
  random-route: true
  docker:
    image: openzipkin/zipkin-slim
  env:
    MEM_MAX_SPANS: 50000</code></pre>
<p>これで<code>cf push</code> / <code>cf push</code>を実行してデプロイしてください。</p>
<p>[1] Blueを削除した場合は、過去のソースコードを再度<code>cf push</code>すればで切り戻すことができます。</p>
<p>[2]このService BrokerはProduction環境での利用は想定されていません。</p>
<p>[3] <a href="https://dataflow.cfapps.io/docs/batch-developer-guides/batch/spring-batch/" target="_blank">https://dataflow.cfapps.io/docs/batch-developer-guides/batch/spring-batch/</a> の内容を改変しました。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
